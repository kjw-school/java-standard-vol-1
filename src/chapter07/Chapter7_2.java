package chapter07;

/**
 * <h1>2. 오버라이딩(overriding)</h1>
 */
public class Chapter7_2 {

	/**
	 * <h5>2.1 오버라이딩이란?</h5><br>
	 * 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만,<br>
	 * 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.
	 */
	class Memo1 {

	}

	/**
	 * <h5>2.2 오버라이딩의 조건</h5><br>
	 * 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.<br>
	 * 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와<br>
	 * <b>- 이름이 같아야 한다.</b><br>
	 * <b>- 매개변수가 같아야 한다.</b><br>
	 * <b>- 반환타입이 같아야 한다.</b><br>
	 * <small>※ JDK1.5부터 '공변 반환타입(convariant return type)'이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.</small><br>
	 * 한마디로 요약하면, 선언부가 서로 일치해야 한다는 것이다. 다만 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경할 수 있다.<br>
	 * <b>1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</b><br>
	 * 만일 조상 클래스에 정의된 메서드와 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 대부분의 경우 같은 범위의 접근 제어자를 사용한다.<br>
	 * 접근 제어자의 접근 범위를 넓은 것에서 좁은 것 순으로 나열하면 public, protected, (default), private이다.<br.
	 * <b>2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.</b><br>
	 * <code>
	 *     class Child extends Parent {<br>
	 *     &nbsp;&nbsp;void parentMethod() throws Exception {<br>
	 *     &nbsp;&nbsp;&nbsp;...<br>
	 *     &nbsp;&nbsp;}<br>
	 *     &nbsp;...<br>
	 *     }
	 * </code>
	 * 여기서 주의해야할 점은 단순히 선언된 예외의 개수의 문제가 아니라는 것이다. 만일 위와 같이 오버라이딩을 하였다면,분명히 조상클래스에 정의된 메서드보다 적은 개수의 예외를<br>
	 * 선언한 것처럼 보이지만, Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이다.<br>
	 * 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때<br>
	 * <b>1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</b><br>
	 * <b>2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.</b><br>
	 * <b>3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.</b><br>
	 */
	class Memo2 {
	}

	/**
	 * <h5>2.3 오버로딩 vs 오버라이딩</h5><br>
	 * 오버로딩은 기존에 없는 새로운 메서드를 추가하는 것이고, 오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.<br>
	 * <b>오버로딩(overloading) - </b> 기존에 없는 새로운 메서드를 정의하는 것(new)<br>
	 * <b>오버라이딩(overriding) - </b> 상속받은 메서드의 내용을 변경하는 것(change, modify)
	 */
	class Memo3 {

	}

	/**
	 * <h5>2.4 super</h5><br>
	 * super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.<br>
	 * 조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super대신 this를 사용할 수 있다.<br>
	 * 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다. 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데,<br>
	 * 이것이 참조변수인 this와 super의 값이 된다.<br>
	 * static메서드(클래스메서드)는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.
	 */
	class Memo4 {

	}

	/**
	 * <h5>2.5 super() - 조상 클래스의 생성자</h5><br>
	 * this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.<br>
	 * 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.<br>
	 * 이 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.<br>
	 * 생성자의 첫 줄에서 조상 클래스의 생성자를 호출해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.<br>
	 * 이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복된다. 마지막으로 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝이 난다.<br>
	 * <b>Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자.this() 또는 super(), 를 호출해야한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.</b><br>
	 * 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요하다.<br>
	 * <b>1. 클래스</b> - 어떤 클래스의 인스턴스를 생성할 것인가?<br>
	 * <b>2. 생성자</b> - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?<br>
	 * <b>조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야한다.</b>
	 */
	class Memo5 {
	}

}
