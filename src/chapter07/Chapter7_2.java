package chapter07;

/**
 * <h1>2. 오버라이딩(overriding)</h1>
 */
public class Chapter7_2 {

	/**
	 * <h5>2.1 오버라이딩이란?</h5><br>
	 * 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만,<br>
	 * 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.
	 */
	class Memo1 {

	}

	/**
	 * <h5>2.2 오버라이딩의 조건</h5><br>
	 * 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.<br>
	 * 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와<br>
	 * <b>- 이름이 같아야 한다.</b><br>
	 * <b>- 매개변수가 같아야 한다.</b><br>
	 * <b>- 반환타입이 같아야 한다.</b><br>
	 * <small>※ JDK1.5부터 '공변 반환타입(convariant return type)'이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.</small><br>
	 * 한마디로 요약하면, 선언부가 서로 일치해야 한다는 것이다. 다만 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경할 수 있다.<br>
	 * <b>1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</b><br>
	 * 만일 조상 클래스에 정의된 메서드와 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 대부분의 경우 같은 범위의 접근 제어자를 사용한다.<br>
	 * 접근 제어자의 접근 범위를 넓은 것에서 좁은 것 순으로 나열하면 public, protected, (default), private이다.<br.
	 * <b>2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.</b><br>
	 * <code>
	 *     class Child extends Parent {<br>
	 *     &nbsp;&nbsp;void parentMethod() throws Exception {<br>
	 *     &nbsp;&nbsp;&nbsp;...<br>
	 *     &nbsp;&nbsp;}<br>
	 *     &nbsp;...<br>
	 *     }
	 * </code>
	 * 여기서 주의해야할 점은 단순히 선언된 예외의 개수의 문제가 아니라는 것이다. 만일 위와 같이 오버라이딩을 하였다면,분명히 조상클래스에 정의된 메서드보다 적은 개수의 예외를<br>
	 * 선언한 것처럼 보이지만, Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이다.<br>
	 * 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때<br>
	 * <b>1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</b><br>
	 * <b>2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.</b><br>
	 * <b>3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.</b><br>
	 */
	class Memo2 {
	}

	/**
	 * <h5>2.3 오버로딩 vs 오버라이딩</h5><br>
	 * 오버로딩은 기존에 없는 새로운 메서드를 추가하는 것이고, 오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.<br>
	 * <b>오버로딩(overloading) - </b> 기존에 없는 새로운 메서드를 정의하는 것(new)<br>
	 * <b>오버라이딩(overriding) - </b> 상속받은 메서드의 내용을 변경하는 것(change, modify)
	 */
	class Memo3 {

	}

	/**
	 * <h5>2.4 super</h5><br>
	 * super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.<br>
	 * 조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super대신 this를 사용할 수 있다.<br>
	 * 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다. 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데,<br>
	 * 이것이 참조변수인 this와 super의 값이 된다.<br>
	 * static메서드(클래스메서드)는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.
	 */
	class Memo4 {

	}

	/**
	 * <h5>2.5 super() - 조상 클래스의 생성자</h5><br>
	 */
	class Memo5 {
	}

}
