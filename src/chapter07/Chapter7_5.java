package chapter07;

/**
 * <h1>5. 다형성(polymorphism)</h1>
 */
public class Chapter7_5 {

	/**
	 * <h5>5.1 다형성이란?</h5><br>
	 * 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.<br>
	 * 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.<br>
	 * 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만, 서로 상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.<br>
	 * 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.<br>
	 * 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 안흔 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는다. 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.<br>
	 * <small>※ 모든 참조변수는 null 또는 4 byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.</small><br>
	 * <pre><code>
	 *     조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
	 *     반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.
	 * </code></pre>
	 */
	class Memo1 {

	}

	/**
	 * <h5>5.2 참조변수의 형변환</h5><br>
	 * 기본형 변수와 같이 참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스사이에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다.<br>
	 * <small>※ 바로 윗 조상이나 자손이 아닌, 조상의 조상으로도 형변환이 가능하다. 따라서 모든 참조변수는 모든 클래스의 조상인 Object클래스 타입으로 형변환이 가능하다.</small><br>
	 * 참조형 변수의 형변환에서는 자손타입의 참조변수를 조상타입으로 형변환하는 경우에는 형변환을 생략할 수 있다.<br>
	 * <pre><code>
	 *     자손타입 -> 조상타입(Up-casting): 형변환 생략가능
	 *     자손타입 <- 조상타입(down-casting): 형변환 생략불가
	 * </code></pre>
	 * 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것을 다운캐스팅(down-casting)이라고 하며, 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것을 업캐스팅(up-casting)이라고 한다.<br>
	 * 조상타입의 참조변수를 Object타입의 참조변수로 형변환 하는 것은 참조 변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다.<br>
	 * 그래서 형변환을 생략할 수 있도록 한 것이다. 하지만, 조상타입의 참조변수를 자손타입으로 변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수를 늘리는 것이므로, 실제 인스턴스의 멤버 개수보다 참조변수가 사용할 수 있는 멤버의 개수가 더 많아지므로 문제가 발생할 가능성이 있다.<br>
	 * 그래서 자손타입으로의 형변환은 생략할 수 없으며, 형변환을 수행하기 전에 instnaceof연산자를 사용해서 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인하는 것이 안전하다.<br>
	 * <b>형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.<br>
	 * 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.</b><br>
	 * 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, <b>참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.</b><br>
	 * <b>그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.</b>
	 */
	class Memo2 {

	}

	/**
	 * <h5>5.3 instanceof연산자</h5><br>
	 * 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다. 주로 조건문에 사용되며, instnaceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치한다.<br>
	 * 그리고 연산의 결과로 boolean값인 true와 false 중의 하나를 반환한다.<br>
	 * instnaceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.<br>
	 * <small>※ 값이 null인 참조변수에 대해 instnaceof연산을 수행하면 false를 결과로 얻는다.</small><br>
	 * 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있기 때문에, 참조변수의 타입과 인스턴스의 타입이 항상 일치하지는 않는다는 것을 배웠다.<br>
	 * 조상타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 참조변수로 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있다.<br>
	 * 실제 인스턴스와 같은 타입의 instnaceof연산 이외에 조상타입의 instnaceof연산에도 true를 결과로 얻으며, instanceof연산의 결과가 true라는 것은 검사한 타입으로의 형변환을 해도 아무런 문제가 없다는 뜻이다.<br>
	 * '참조변수.getClass().getName()'은 참조변수가 가리키고 있는 인스턴스의 클래스 이름을 문자열(String)로 반환한다.<br>
	 * <b>어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.</b>
	 */
	class Memo3 {

	}

	/**
	 * <h5>5.4 참조변수와 인스턴스의 연결</h5><br>
	 * 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다.<br>
	 * 메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출되지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.<br>
	 * <small>※ static메서드는 static변수처럼 참조변수의 타입에 영향을 받는다. 참조변수의 타입에 영향을 받지 않는 것은 인스턴스메서드 뿐이다. 그래서 static메서드는 반드시 참조변수가 아닌 '클래스이름.메서드()'로 호출해야 한다.</small><br>
	 * 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.<br>
	 * 하지만 중복 정의되지 않은 경우, 조상타입의 참조변수를 사용했을 때와 자손타입의 참조변수를 사용했을 때의 차이는 없다. 중복된 경우는 참조변수의 타입에 따라 달라지지만, 중복되지 않은 경우 하나뿐이므로 선택의 여지가 없기 때문이다.<br>
	 */
	class Memo4 {

	}

	/**
	 * <h5>5.5 매개변수의 다형성</h5><br>
	 * 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>5.6 여러 종류의 객체를 배열로 다루기</h5><br>
	 * 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다. 또는 묶어서 다루고싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다.
	 */
	class Memo6 {

	}

}
