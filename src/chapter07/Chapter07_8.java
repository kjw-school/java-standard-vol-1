package chapter07;

/**
 * <h1>8. 내부 클래스(inner class)</h1><br>
 * 내부 클래스는 클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않다.
 */
public class Chapter07_8 {

	/**
	 * <h5>8.1 내부 클래스란?</h5><br>
	 * 내부 클래스는 클래스 내에 선언된 클래스이다. 클래스에 다른 클래스를 선언하는 이유는 간단하다. 두 클래스가 서로 긴밀한 관계에 있기 때문이다.<br>
	 * <pre><code>
	 *     내부 클래스의 장점
	 *     - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
	 *     - 코드의 복잡성을 줄일 수 있다(캡슐화).
	 * </code></pre>
	 */
	class Memo1 {

	}

	/**
	 * <h5>8.2 내부 클래스의 종류와 특징</h5><br>
	 * 내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다.<br>
	 * 내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스변수, 클래스변수(static변수), 지역변수로 구분되는 것과 같이 내부 클래스도 선언위치에 따라 다음과 같이 구분되어 진다.<br>
	 * <table>
	 *     <thead>
	 *         <th>내부 클래스</th>
	 *         <th>특징</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>인스턴스 클래스(instance class)</td>
	 *             <td>외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.</td>
	 *         </tr>
	 *         <tr>
	 *             <td>스태틱 클래스(static class)</td>
	 *             <td>외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다.</td>
	 *         </tr>
	 *         <tr>
	 *             <td>지역 클래스(local class)</td>
	 *             <td>외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.</td>
	 *         </tr>
	 *         <tr>
	 *             <td>익명 클래스(anonymous class)</td>
	 *             <td>클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 */
	class Memo2 {

	}

	/**
	 * <h5>8.3 내부 클래스의 선언</h5><br>
	 * 각 내부 클래스의 선언위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성(accessibility)을 갖는다.
	 */
	class Memo3 {

	}

	/**
	 * <h5>8.4 내부 클래스의 제어자와 접근성</h5><br>
	 * 내부 클래스 중에서 스태틱 클래스만 static멤버를 가질 수 있다. 내부 클래스에 static변수를 선언해야한다면 스태틱 클래스로 선언해야한다.<br>
	 * 다만 final과 static이 동시에 붙은 변수는 상수(constant)이므로 모든 내부 클래스에서 정의가 가능하다.<br>
	 * 인스턴스멤버는 같은 클래스에 있는 인스턴스멤버와 static멤버 모두 직접 호출이 가능하지만, static멤버는 인스턴스멤버를 직접 호출할 수 없는 것처럼, 인스턴스클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 바로 사용할 수 있지만,<br>
	 * 스태틱 클래스는 외부 클래스의 인스턴스멤버를 객체생성 없이 사용할 수 없다.<br>
	 * 마찬가지로 인스턴스클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만, 스태틱 클래스에서는 인스턴스클래스의 멤버들을 객체생성 없이 사용할 수 없다.<br>
	 * JDK1.8부터 지역 클래스에서 접근하는 지역 변수 앞에 final을 생략할 수 있게 바뀌었다. 대신 컴파일러가 자동으로 붙여준다. 즉, 편의상 final을 생략할 수 있게 한 것일 뿐 해당 변수의 값이 바뀌는 문장이 있으면 컴파일 에러가 발생한다.<br>
	 * 컴파일 했을 때 생성되는 파일명은 '외부 클래스명$내부 클래스명.class'형식으로 되어 있다. 다만 서로 다른 메서드 내에서는 같은 이름의 지역변수를 사용하는 것이 가능한 것처럼, 지역내부 클래스는 다른 메서드에 같은 이름의 내부 클래스가 존재할 수 있기 때문에 내부 클래스명 앞에 숫자가 붙는다.
	 */
	class Memo4 {

	}

	/**
	 * <h5>8.5 익명 클래스(anonymous class)</h5><br>
	 * 익명 클래스는 특이하게도 다른 내부 클래스들과는 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.<br>
	 * <pre><code>
	 *     new 조상클래스이름() {
	 *         // 멤버 선언
	 *     }
	 *     또는
	 *     new 구현인터페이스이름() {
	 *         // 멤버 선언
	 *     }
	 * </code></pre>
	 * <br>
	 * 이름이 없기 때문에 생성자도 가질 수 없으며, 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다.<br>
	 * 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.
	 */
	class Memo5 {

	}

}
