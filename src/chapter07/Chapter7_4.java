package chapter07;

/**
 * <h1>4. 제어자(modifier)</h1>
 */
public class Chapter7_4 {

	/**
	 * <h5>4.1 제어자란?</h5><br>
	 * 제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.<br>
	 * <pre><code>
	 *     접근 제어자 - public, protected, default, private
	 *     그 외 - static, final, abstract, native, transient, synchronized, volatile, strictfp
	 * </code></pre>
	 * <br>
	 * 제어자는 클래스나 멤버변수와 메서드에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.<br>
	 * 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다. 즉, 하나의 대상에 대해서 public과 private을 함께 사용할 수 없다는 것이다.<br>
	 * <small>※제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.</small>
	 */
	class Memo1 {

	}

	/**
	 * <h5>4.2 static - 클래스의, 공통적인</h5><br>
	 * static은 '클래스의' 또는 '공통적인' 의미를 가지고 있다. 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다.<br>
	 * 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문이다.<br>
	 * static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.<br>
	 * 인스턴스메서드와 static메서드의 근본적인 차이는 메서드 내에서 인스턴스 멤버를 사용하는가의 여부에 있다.<br>
	 * <pre><code>
	 *     static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
	 * </code></pre>
	 * <br>
	 * <table border="1">
	 *     <thead>
	 *         <tr>
	 *             <th>제어자</th>
	 *             <th>대상</th>
	 *             <th>의미</th>
	 *         </tr>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td rowspan="2">static</td>
	 *             <td>멤버변수</td>
	 *             <td>
	 *                 - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
	 *                 - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
	 *                 - 클래스가 메모리에 로드될 때 생성된다.
	 *             </td>
	 *         </tr>
	 *         <tr>
	 *             <td>메서드</td>
	 *             <td>
	 *                 - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
	 *                 - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.
	 *             </td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 * <small>※ static초기화 블럭은 클래스가 메모리에 로드될 때 단 한번만 수행되며, 주로 클래스변수(static변수)를 초기화하는데 주로 사용한다.</small>
	 */
	class Memo2 {

	}

	/**
	 * <h5>4.3 final - 마지막의, 변경될 수 없는 </h5><br>
	 * final은 '마지막의' 또는 '변경될 수 없는'의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.<br>
	 * 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고, 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.<br>
	 * <b>final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수</b><br>
	 * <table border="1">
	 *    <thead>
	 *        <th>제어자</th>
	 *        <th>대상</th>
	 *        <th>의미</th>
	 *    </thead>
	 *    <tbody>
	 *        <tr>
	 *            <td rowspan="4">final</td>
	 *        </tr>
	 *        <tr>
	 *            <td>클래스</td>
	 *            <td>변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.</td>
	 *        </tr>
	 *        <tr>
	 *            <td>메서드</td>
	 *            <td>변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.</td>
	 *        </tr>
	 *        <tr>
	 *            <td>지역변수 / 멤버변수</td>
	 *            <td>변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.</td>
	 *        </tr>
	 *    </tbody>
	 * </table>
	 * <br>
	 * <small>※대표적인 final클래스로는 String과 Math가 있다.</small>
	 */
	class Memo3 {

	}

	/**
	 * <h5>생성자를 이용한 final멤버 변수의 초기화</h5><br>
	 * final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.<br>
	 * 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것이다.<br>
	 * 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능하다.
	 */
	class Memo4 {

	}

	/**
	 * <h5>4.4 abstract - 추상의, 미완성의</h5><br>
	 * abstract는 '미완성'의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.<br>
	 * <b>abstract가 사용될 수 있는 곳 - 클래스, 메서드</b><br>
	 * <table border="1">
	 *     <thead>
	 *         <th>제어자</th>
	 *         <th>대상</th>
	 *         <th>의미</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td rowspan="2">abstract</td>
	 *             <td>클래스</td>
	 *             <td>클래스 내에 추상 메서드가 선언되어 있음을 의미한다.</td>
	 *         </tr>
	 *         <tr>
	 *             <td>메서드</td>
	 * 	           <td>선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 * 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>4.5 접근 제어자(access modifier)</h5><br>
	 * 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.<br>
	 * 접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다. 클래스나 멤버변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.<br>
	 * <pre><code>
	 *     접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
	 *     private 같은 클래스 내에서만 접근이 가능하다.
	 *     default 같은 패키지 내에서만 접근이 가능하다.
	 *     protected 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
	 *     public 접근 제한이 전혀 없다.
	 * </code></pre>
	 * <br>
	 * 접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 왼쪽부터 나열하면 다음과 같다.<br>
	 * <b>public > protected > (default) > private</b><br>
	 * public은 접근 제한이 전혀 없는 것이고, private은 같은 클래스 내에서만 사용하도록 제한하는 가장 높은 제한이다.<br>
	 * 그리고 default는 같은 패키지내의 클래스에서만 접근이 가능하도록 하는 것이다.<br>
	 * 마지막으로 protected는 패키지에 관계없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한목적이지만, 같은 패키지 내에서도 접근이 가능하다.<br>
	 * 그래서 protected가 default보다 접근범위가 더 넓다.<br>
	 * <small>※ 접근 제어자가 default라는 것은 아무런 접근 제어자도 붙이지 않는 것을 의미한다.</small>
	 * <br>
	 * <table border="1">
	 *     <thead>
	 *         <th>대상</th>
	 *         <th>사용가능한 접근 제어자</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>클래스</td>
	 *             <td>public, (default)</td>
	 *         </tr>
	 *         <tr>
	 *             <td>메서드</td>
	 *             <td rowspan="2">public, protected, (default), private</td>
	 *         </tr>
	 *         <tr>
	 *             <td>멤버변수</td>
	 *         </tr>
	 *         <tr>
	 *             <td>지역변수</td>
	 *             <td>없음</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 */
	class Memo6 {

	}

	/**
	 * <h5>접근 제어자를 이용한 캡슐화</h5><br>
	 * 클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.<br>
	 * 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.<br>
	 * 이것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 캡슐화(encapsulation)에 해당하는 내용이다.<br>
	 * 또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서이다.<br>
	 * 외부에서 접근할 필요가 없는 멤버들을 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다. 이것 역시 캡슐화에 해당한다.<br>
	 * <pre><code>
	 *     접근 제어자를 사용하는 이유
	 *     - 외부로부터 데이터를 보호하기 위해서
	 *     - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
	 * </code></pre>
	 */
	class Memo7 {

	}

}
