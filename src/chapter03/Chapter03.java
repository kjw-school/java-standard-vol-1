package chapter03;

/**
 * <h1>Chapter03. 연산자 operator</h1>
 */
public class Chapter03 {

	/**
	 * <p>
	 *     <h5>1. 연산자(operator)</h5><br>
	 *     연산자는 '연산을 수행하는 기호'를 말한다.
	 * </p>
	 */
	class Memo01 {
	}

	/**
	 * <p>
	 *		<h5>1.1 연산자와 피연산자</h5><br>
	 * 	 	연산자가 연산을 수행하려면 반드시 연산의 대상이 있어야하는데, 이것을 '피연산자(operand)'라고 한다.<br>
	 * 	 	피연산자로 상수, 변수 또는 식(式) 등을 사용할 수 있다.<br>
	 * 	 	<b>연산자(operator) - 연산을 수행하는 기호(+, -, *, / 등)</b><br>
	 * 	 	<b>피연산자(operand) - 연산자의 작업 대상(변수, 상수, 리터럴, 수식)</b><br>
	 * 	 	<b>연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.</b>
	 * </p>
	 */
	class Memo02 {
	}

	/**
	 * <p>
	 * 		<h5>식(式)과 대입연산자</h5><br>
	 * 		연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 '식(式, expression)'이라고 한다.<br>
	 * 		식을 계산하여 결과를 얻는 것을 '식을 평가(evaluation)한다'고 한다.<br>
	 * 		하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다.
	 * </p>
	 */
	class Memo03 {
	}

	/**
	 * <h5>1.3 연산자의 종류</h5><br>
	 * <table border="1">
	 *     <thead>
	 *         <th>종류</th>
	 *         <th>연산자</th>
	 *         <th>설명</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>산술 연산자</td>
	 *             <td>+ - * / % << >></td>
	 *             <td>사칙 연산(+, -, *, /)과 나머지 연산(%)</td>
	 *         </tr>
	 *         <tr>
	 *             <td>비교 연산자</td>
	 *             <td>> < >= <= == !=</td>
	 *             <td>크고 작음과 같고 다름을 비교</td>
	 *         </tr>
	 *         <tr>
	 *             <td>논리 연산자</td>
	 *             <td>&& !! ! * ! ^ ~</td>
	 *             <td>'그리고(AND)'와 '또는(OR)'으로 조건을 연결</td>
	 *         </tr>
	 *         <tr>
	 *             <td>대입 연산자</td>
	 *             <td>=</td>
	 *             <td>우변의 값을 좌변에 저장</td>
	 *         </tr>
	 *         <tr>
	 *             <td>기타</td>
	 *             <td>(type) ?: instanceof</td>
	 *             <td>형변환 연산자, 삼항 연산자, instanceof연산자</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 */
	class Memo04 {
	}

	/**
	 * <h5>피연산자의 개수에 의한 분류</h5><br>
	 * 피연산자의 개수가 하나면 '단항 연산자', 두 개면'이항 연산자', 세 개면'삼항 연산자'라고 부른다. 대부분의 연산자는 '이항 연산자'이고, 삼항 연산자는 오직'? :' 하나뿐이다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>1.4 연산자의 우선순위와 결합규칙</h5><br>
	 * 식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.<br>
	 * 곱셈과 나눗셈(*,/)은 덧셈과 뺄셈(+,-)보다 우선순위가 높다는 것은 이미 수학에서 배워서 알고 있을 것이다.<br>
	 * 단항 연산자가 이항 연산자보다 우선순위가 높다. 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.<br>
	 * <small>※ 괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 지정할 떄 사용하는 기호일 뿐이다.</small>
	 */
	class Memo6 {

	}

	/**
	 * <h5>연산자의 결합규칙</h5><br>
	 * 하나의 식에 우선순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 연산을 수행할까?<br>
	 * 그 규칙을 <b>'연산자의 결합규칙'</b>이라고 한다.<br>
	 * 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고, 단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로, 연산을 수행한다.<br>
	 * <pre><code>
	 *     1. 산술 > 비교 > 논리 > 대입, 대입은 제일 마지막에 수행된다.
	 *     2. 단항(1) > 이항(2) > 삼항(3), 단항 연산자의 운선순위가 이항 연산자보다 높다.
	 *     3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
	 * </code></pre>
	 * <small>※ 단항연산자에 있는 '+'와 '-'는 부호연산자이고 '(type)'은 형변환 연산자이다.</small>
	 */
	class Memo7 {

	}

	/**
	 * <h5>1.5 산술 변환(usual arithmetic conversion)</h5><br>
	 * 이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.<br>
	 * 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 '산술 변환' 또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.<br>
	 * '산술 변환'의 규칙<br>
	 * <pre><code>
	 * 		1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
	 * 			long + int -> long + long -> long
	 * 			float + int -> float + float -> float
	 * 		    double + float -> double + double > double
	 * 		2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
	 * 			byte + short -> int + int -> int
	 * 			char + short -> int + int -> int
	 * </code></pre>
	 * <br>
	 * <small>※ 모든 연산에서 '산술 변환'이 일어나지만, 쉬프트 연산자 (<<, >>), 증감 연산자(++, --)는 예외이다.</small>
	 * <br>
	 * <code><pre>
	 *     산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
	 *     1. 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)
	 *     2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
	 * </pre></code>
	 */
	class Memo8 {

	}

}
