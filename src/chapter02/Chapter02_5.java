package chapter02;

/**
 * <h1>5. 형변환</h1>
 */
public class Chapter02_5 {

	/**
	 * <h5>5.1 형변환(캐스팅, casting)이란?</h5><br>
	 * 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 '형변환(casting)'이라고 한다.<br>
	 * <b>형변환 이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것</b>
	 */
	class Memo1 {

	}

	/**
	 * <h5>5.2 형변환 방법</h5><br>
	 * 형변환 방법은 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.<br>
	 * <b>(타입)피연산자</b><br>
	 * 여기에 사용되는 괄호()는 '캐스트 연산자' 또는 '형변환 연산자'라고 하며, 형변환을 '캐스팅(casting)'이라고도 한다.<br>
	 * <code>
	 *     double d = 85.4;<br>
	 *     int score = (int)d; // double타입의 변수 d를 int타입으로 형변환
	 * </code>
	 * <br>
	 * <b>피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.</b><br>
	 * 기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다. 그리고 기본형과 참조형간의 형변환은 불가능하다.
	 */
	class Memo2 {
	}

	/**
	 * <h5>5.3 정수형간의 형변환</h5><br>
	 * 큰 타입에서 작은 타입으로의 변환, int타입(4 byte)의 값을 byte타입(1 byte)으로 변환하는 경우 경우에 따라 '값 손실(loss of data)'이 발생할 수 있다.<br>
	 * <table border="1">
	 *     <thead>
	 *         <td>변환</td>
	 *         <td>2진수</td>
	 *         <td>10진수</td>
	 *         <td>값손실</td>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>int -> byte</td>
	 *             <td>
	 *                 00000000 00000000 00000000 00001010<br>
	 *                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00001010
	 *             </td>
	 *             <td>
	 *                 10<br>
	 *                 10
	 *             </td>
	 *             <td>없음</td>
	 *         </tr>
	 *         <tr>
	 *             <td>int -> byte</td>
	 *             <td>
	 *                 00000000 00000000 00000001 00101100<br>
	 *                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00101100
	 *             </td>
	 *             <td>
	 *                 300<br>
	 *                 44
	 *             </td>
	 *             <td>있음</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 * 반대로 작은 타입에서 큰 타입으로의 변환, 예를 들어서 byte타입(1 byte)의 값을 int타입(4 byte)으로 변환하는 경우는 저장공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않는다.<br>
	 * 나머지 빈공간은 0 또는 1로 채워진다.<br>
	 * 원래의 값을 채우고 남은 빈공간은 0으로 채우는 게 보통이지만, 변환하려는 값이 음수인 경우에는 빈 공간을 1로 채운다.
	 */
	class Memo3 {
	}

	/**
	 * <h5>5.4 실수형 간의 형변환</h5><br>
	 * 실수형에서도 정수형 처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다. float타입의 값을 double타입으로 변환하는 경우, 지수(E)는 float의 기저인 127을 뺀 후 double의 기저인 1023을 더해서 변환하고, 가수(M)는 float의 기수 23자리를 채우고 남은 자리를 0으로 채운다.<br>
	 * 반대로 double타입에서 float타입으로 변환하는 경우, 지수(E)는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더하고 가수(M)는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려진다.<br>
	 * 한 가지 주의할 점은 형변환 할 때 가수의 24번째 자리에서 반올림이 발생할 수 있다는 것이다. 24번째 자리의 값이 1이면, 반올림이 발생하여 23번째 자리의 값이 1증가한다.<br>
	 * 그리고 float타입의 범위를 넘는 값을 float로 형변환하는 경우는 '&plusmn;무한대' 또는 '&plusmn;0'을 결과로 얻는다.
	 */
	class Memo4 {

	}

	/**
	 * <h5>5.5 정수형과 실수형 간의 형변환</h5><br>
	 * <b>int : 1 + 31 = 32 (4 byte, S(1), 31bit)</b><br>
	 * <b>float : 1 + 8 + 23 = 32 (4 byte, S(1), E(8), M(23)</b><br>
	 * <h6>정수형을 실수형으로 변환</h6><br>
	 * 정수는 소수점이하의 값이 없으므로 비교적 변환이 간단하다. 그저 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장될 뿐이다.<br>
	 * 실수형은 정수형보다 훨씬 큰 저장범위를 갖기 떄문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 한 가지 주의할 점은 실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다는 것이다.<br>
	 * <h6>실수형을 정수형으로 변환</h6><br>
	 * 실수형을 정수형으로 변환하면, 실수형의 소수점이하 값은 버려진다. 실수형을 정수형으로 형변환할 때 반올림이 발생하지 않는다.<br>
	 * <b>1.666 ---(int)----> 1</b><br>
	 * 만일 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는 정수의 오버플로우가 발생한 결과를 얻는다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>5.6 자동 형변환</h5><br>
	 * 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다. 그렇다고 해서 형변환이 이루어지지 않는 것은 아니고, 컴파일러가 생략된 형변환을 자동적으로 추가한다.<br>
	 * 계산식에서 자주 형변환이 생략되는데, 서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 다음에 연산을 수행해야 하므로, 연산과정에서 형변환이 자동적으로 이루어진다.<br>
	 * 서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행한다.<br>
	 * 그렇게 하는 것이 값손실의 위험이 더 적어서 올바른 결과를 얻을 확률이 높기 때문이다.<br>
	 */
	class Memo6 {

	}

	/**
	 * <h5>자동 형변환의 규칙</h5><br>
	 * <b>기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.</b><br>
	 * 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.<br>
	 * byte(1byte) -> short(2byte) -> int(4byte) -> long(8byte) -> float(4byte) -> double(8byte)<br>
	 * <pre>                          char</pre>           <br>
	 * <small>※정수형을 실수형으로 형변환 하는 경우, 정밀도의 한계로 인한 오차가 발생할 수 있다.</small><br>
	 * <pre><code>
	 *     1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
	 *     2. 기본형과 참조형은 서로 형변환할 수 없다.
	 *     3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
	 * </code></pre>
	 */
	class Memo7 {

	}

}
