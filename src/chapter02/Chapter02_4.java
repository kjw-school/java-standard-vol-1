package chapter02;

/**
 * <h1>4. 기본형(primitive type)</h1>
 */
public class Chapter02_4 {

	/**
	 * <h5>4.1 논리형 - boolean</h5><br>
	 * 논리형에는 'boolean' 한가지 밖에 없다. boolean형 변수에는 true와 false 중 하나를 저장할 수 있으며 기본값(default)은 false이다.<br>
	 * 자바에서는 대소문자가 구별되기 떄문에 TRUE와 true는 다른 것으로 간주된다는 것에 주의하자.
	 */
	class Memo01 {
	}

	/**
	 * <h5>4.2 문자형 - char</h5><br>
	 * 문자형 역시 'char'한 가지 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며, char타입의 변수는 단 하나의 문자만을 저장할 수 있다.<br>
	 * 변수에 '문자'가 저장되는 것 같지만, 사실은 문자가 아닌 '문자의 유니코드(정수)'가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장하는 것이다.<br>
	 * 문자'A'의 유니코드는 65이르모, 변수 ch에는 65가 저장된다.<br>
	 * char ch = 'A'; // 문자 'A'를 char타입의 변수 ch에 저장.<br>
	 * 그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.<br>
	 * 만일 어떤 문자의 유니코드를 알고 싶으면, char형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.
	 */
	class Memo02 {
	}

	/**
	 * <h5>특수 문자 다루기</h5><br>
	 * <table border="1">
	 *     <tr>
	 *         <th>특수 문자</th>
	 *         <th>문자 리터럴</th>
	 *     </tr>
	 *     <tr>
	 *         <td>tab</td>
	 *         <td>\t</td>
	 *     </tr>
	 *     <tr>
	 *         <td>backspace</td>
	 *         <td>\b</td>
	 *     </tr>
	 *     <tr>
	 *         <td>form feed</td>
	 *         <td>\f</td>
	 *     </tr>
	 *     <tr>
	 *         <td>new line</td>
	 *         <td>\n</td>
	 *     </tr>
	 *     <tr>
	 *         <td>carriage return</td>
	 *         <td>\r</td>
	 *     </tr>
	 *     <tr>
	 *         <td>역슬래쉬(\)</td>
	 *         <td>\\</td>
	 *     </tr>
	 *     <tr>
	 *         <td>작은따옴표</td>
	 *         <td>\'</td>
	 *     </tr>
	 *     <tr>
	 *         <td>큰따옴표</td>
	 *         <td>\"</td>
	 *     </tr>
	 *     <tr>
	 *         <td>유니코드(16진수)문자</td>
	 *         <td>'\'u유니코드(예 char a='\u00041')</td>
	 *     </tr>
	 * </table>
	 */
	class Memo03 {

	}

	/**
	 * <h5>char타입의 표현형식</h5><br>
	 * char타입의 크기는 2 byte(=16 bit)이므로, 16자리의 2진수로 표현할 수 있는 정수의 개수인 65536개(=2<sup>16</sup>)의 코드를 사용할 수 있으며,<br>
	 * char형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다.<br>
	 * char타입은 문자를 저장할 변수를 선언하기 위한 것이지만, 실제로 char타입의 변수에는 문자가 아닌 '문자의 유니코드(정수)'가 저장되고, 표현형식 역시 정수형과 동일하다.<br>
	 * 다만, 정수형과 달리 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다르다.<br>
	 * 2 byte(= 16bit)로는 모두 2^16(=65536)개의 값을 표현할 수 있는데, char타입에 저장되는 값인 유니코드는 모두 양수(0 포함)이므로, '0~65535)의 범위를 가지며,<br>
	 * 정수형인 'short'은 절반을 음수표현에 사용하므로 '-32768~32767`을 범위로 갖는다.<br>
	 * <b>16비트로 표현할 수 있는 정수의 개수: 2^16개(65536개)</b><br>
	 * short타입의 표현범위: -2^16 ~ 2^16-1(-32768~32767)<br>
	 * char타입의 표현범위: 0~2^16-1(0~65535)
	 */
	class Memo04 {
	}

	/**
	 * <h5>인코딩과 디코딩(encoding & decoding)</h5><br>
	 * 문자를 코드로 변환하는 것을 '문자 인코딩(encoding)', 그 반대로 코드를 문자로 변환하는 것을 '문자 디코딩(decoding)'이라고 한다.<br>
	 * 문자를 저장할 때는 인코딩을 해서 숫자로 변환해서 저장하고, 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌려야 한다
	 */
	class Memo05 {
	}

	/**
	 * <h5>아스키(ASCII)</h5><br>
	 * 'ASCII'는 'American Standard Code for Information Interchange'의 약어로 정보교환을 위한 미국 표준 코드란 뜻이다.<br>
	 * 아스키는 128개(=2^7)의 문자 집합(character set)을 제공하는 7bit 부호로,<br>
	 * 처음 32개의 문자는 인쇄와 전송 제어용으로 사용되는 '제어문자(control character)'로 출력할 수 없고 마지막 문자(DEL)을 제외한 33번째 이후의 문자들은 출력할 수 있는 문자들로, 기호와 숫자, 영대소문자로 이루어져 있다.
	 */
	class Memo06 {
	}

	/**
	 * <h5>유니코드(Unicode)</h5><br>
	 * 예전엔 같은 지역 내에서만 문서교환이 주를 이뤘지만, 인터넷이 발명되면서 서로 다른 지역의 다른 언어를 사용하는 컴퓨터간의 문서교환이 활발해지기 시작하자 서로 다른 문자 인코딩을 사용하는 컴퓨터간의 문서교환에 어려움을 겪게 되었다.<br>
	 * 이러한 어려움을 해소하고자 전 세계의 문자를 하나의 통일된 문자집합으로 표현하고자 노력하였고 그 결과가 바로 '유니코드'이다.<br>
	 * 유니코드는 처음엔 모든 문자를 2 byte(=2^16=65536)로 표현하려했으나, 2 byte(=16 bit)로도 부족해서 21 bit(약 200만 문자)로 확장되었다.<br>
	 * 새로 추가된 문자들을 보충 문자(supplementary character)라고 하는데 이 문자들을 표현하기 위해서는 char타입이 아닌 int타입을 사용해야 한다.<br>
	 * 유니코드는 먼저 유니코드에 포함시키고자 하는 문자들의 집합을 정의하였는데, 이것을 유니코드 문자 셋(또는 캐릭터 셋, character set)이라고 한다.<br>
	 * 그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다. 유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 등 여러가지 종류가 있는데 자바에서는 UTF-16을 사용한다.<br>
	 * UTF-16은 모든 문자를 2 byte의 고정크기로 표현하고 UTF-8은 하나의 문자를 1~4 byte의 가변크기로 표현한다.<br>
	 * 그리고 두 인코딩 모두 처음 128문자가 아스키와 동일하다.<br>
	 * <small>※코드 포인트(code point)는 유니코드 문자 셋에 순서대로 붙인 일련번호이다. 유니코드에는 뭐라고 읽는지도 알 수 없는 문자들이 많이 포함되어 있으므로, 이 문자들은 번호(코드 포인트)로 다루는 것이 편리하다.</small><br>
	 * 모든 문자의 크기가 동일한 UTF-16의 문자를 다루기는 편리하지만, 1 byte로 표현할 수 있는 영어와 숫자가 2 byte로 표현되므로 문서의 크기가 커진다는 단점이 있다.<br>
	 * UTF-8에서 영문과 숫자는 1 byte 그리고 한글은 3 byte로 표현되기 때문에 문서의 크기가 작지만 문자의 크기가 가변적이므로 다루기 어렵다는 단점이 있다.
	 */
	class Memo07 {
	}

	/**
	 * <h5>4.3 정수형 - byte, short, int, long</h5><br>
	 * 정수형에는 모두 4개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다.<br>
	 * byte(1) < short(2) < int(4) < long(8)<br>
	 * 이 중에서도 기본 자료형(default data type)은 int이다.
	 */
	class Memo08 {
	}

	/**
	 * <h5>정수형의 표현형식과 범위</h5><br>
	 * 정수형은 다음과 같은 형식으로 저장된다.<br>
	 * S | n-1 bit<br>
	 * S: 부호 비트(양수는 0, 음수는 1)<br>
	 * n: 타입의 크기(단위:bit)<br>
	 * 모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 '부호 비트(sign bit)'로 사용하고, 나머지는 값을 표현하는데 사용한다.<br>
	 * 그래서 n비트로 표현할 수 있는 값의 개수인 2^n개에서, 절반인 '0'으로 시작하는 2^n-1개의 값을 양수(0도 포함)의 표현에 사용하고,<br>
	 * 나머지 절반인 '1'로 시작하는 2^n-1개의 값은 음수의 표현에 사용한다.<br>
	 *<table border="1">
	 *     <tr>
	 *         <th>정수형의 표현형식(n bit)</th>
	 *         <th>종류</th>
	 *         <th>값의 개수</th>
	 *     </tr>
	 *     <tr>
	 *         <td>0 | n-1 bit</td>
	 *         <td>0, 양수</td>
	 *         <td>2^n-1개</td>
	 *     </tr>
	 *     <tr>
	 *         <td>1 | n-1 bit</td>
	 *         <td>음수</td>
	 *         <td>2^n-1개</td>
	 *     </tr>
	 *</table><br>
	 * <b>n비트로 표현할 수 있는 정수의 개수: 2^개(= 2^n-1개 + 2^n-1개)</b><br>
	 * <b>n비트로 표현할 수 있는 부호있는 정수의 범위 : -2^n-1 ~ 2n-1 - 1</b><br>
	 * <b>8비트로 표현할 수 있는 정수의 개수: 2^8개(= 2^7개 + 2^7개)</b><br>
	 * <b>8비트로 표현할 수 있는 부호있는 정수의 범위: -2^7 ~ 2^7 -1(-128 ~ 127)</b><br>
	 * <table>
	 *     <tr>
	 *         <th>타입</th>
	 *         <th>저장 가능한 값의 범위</th>
	 *         <th>bit</th>
	 *         <th>byte</th>
	 *     </tr>
	 *     <tr>
	 *         <td>byte</td>
	 *         <td>-128 ~ 127(-2^7 ~ 2^7-1)</td>
	 *         <td>8</td>
	 *         <td>1</td>
	 *     </tr>
	 *     <tr>
	 *         <td>short</td>
	 *         <td>-32,768 ~ 32,767(-2^15 ~ 2^15 -1)</td>
	 *         <td>16</td>
	 *         <td>2</td>
	 *     </tr>
	 *     <tr>
	 *         <td>int</td>
	 *         <td>-2,147,483,648 ~ 2,147,483,647(-2^31 ~ 2^31 -1, 약 +-20억)</td>
	 *         <td>32</td>
	 *         <td>4</td>
	 *     </tr>
	 *     <tr>
	 *         <td>long</td>
	 *         <td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807(-2^63 ~ 2^63 -1)</td>
	 *         <td>64</td>
	 *         <td>8</td>
	 *     </tr>
	 * </table>
	 */
	class Memo09 {

	}

	/**
	 * <h5>정수형의 선택기준</h5><br>
	 * 변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 선택하면 된다.<br>
	 * JVM의 피연산자 스택(operand stack)이 피연산자를 4 byte단위로 저장하기 때문에 크기가 4byte보다 작은 자료형(byte, short)의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다.<br>
	 * 그래서 오히려 int를 사용하는 것이 더 효율적이다.<br>
	 * <b>2^10 = 1024 = 10^3 이므로, 2^32 = 2^10 x 2^10 x 2^10 x 2^2 = 1024 x 1024 x 1024 x 4 = 4 X10^3</b><br>
	 * <b>정수형 변수를 선언할 때는 int타입으로 하고, int의 범위(약 +=20억)를 넘어 서는 수를 다뤄야할 때는 long을 사용하면 된다.</b>
	 */
	class Memo10 {
	}

	/**
	 * <h5>정수형의 오버플로우</h5><br>
	 * 원래 2진수 '1111'에 1을 더하면 '10000'이 되지만, 4 bit로는 4자리의 2진수만 저장할 수 있기 때문에 '0000'이 된다.<br>
	 * 즉, 5자리의 2진수 '10000'중에서 하위 4 bit만 저장하게 되는것이다.<br>
	 * 연산과정에서 <b>해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)</b>라고 한다.<br>
	 * 정수형 타입이 표현할 수 있는 최대값에 1을 더하면 최소값이 되고, 최소값에서 1을 빼면 최대값이 된다.<br>
	 * <b>최대값 + 1 -> 최소값</b><br>
	 * <b>최소값 - 1 -> 최대값</b>
	 */
	class Memo11 {
	}

	/**
	 * <h5>부호있는 정수의 오버플로우</h5><br>
	 * <b>부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다.</b><br>
	 * <table border="1">
	 *     <thead>
	 *         <th>부호없는 10진수</th>
	 *         <th>2진수</th>
	 *         <th>부호있는 10진수</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>0</td>
	 *             <td>0000</td>
	 *             <td>0</td>
	 *         </tr>
	 *         <tr>
	 *             <td>1</td>
	 *             <td>0001</td>
	 *             <td>1</td>
	 *         </tr>
	 *         <tr>
	 *             <td>2</td>
	 *             <td>0010</td>
	 *             <td>2</td>
	 *         </tr>
	 *         <tr>
	 *             <td>3</td>
	 *             <td>0011</td>
	 *             <td>3</td>
	 *         </tr>
	 *         <tr>
	 *             <td>4</td>
	 *             <td>0100</td>
	 *             <td>4</td>
	 *         </tr>
	 *         <tr>
	 *             <td>5</td>
	 *             <td>0101</td>
	 *             <td>5</td>
	 *         </tr>
	 *         <tr>
	 *             <td>6</td>
	 *             <td>0110</td>
	 *             <td>6</td>
	 *         </tr>
	 *         <tr>
	 *             <td>7</td>
	 *             <td>0111</td>
	 *             <td>7 <- 최대값</td>
	 *         </tr>
	 *         <tr>
	 *             <td>8</td>
	 *             <td>1000</td>
	 *             <td>-8 <- 최소값</td>
	 *         </tr>
	 *         <tr>
	 *             <td>9</td>
	 *             <td>1001</td>
	 *             <td>-7</td>
	 *         </tr>
	 *         <tr>
	 *             <td>10</td>
	 *             <td>1010</td>
	 *             <td>-6</td>
	 *         </tr>
	 *         <tr>
	 *             <td>11</td>
	 *             <td>1011</td>
	 *             <td>-5</td>
	 *         </tr>
	 *         <tr>
	 *             <td>12</td>
	 *             <td>1100</td>
	 *             <td>-4</td>
	 *         </tr>
	 *         <tr>
	 *             <td>13</td>
	 *             <td>1101</td>
	 *             <td>-3</td>
	 *         </tr>
	 *         <tr>
	 *             <td>14</td>
	 *             <td>1110</td>
	 *             <td>-2</td>
	 *         </tr>
	 *         <tr>
	 *             <td>최대값 -> 15</td>
	 *             <td>1111</td>
	 *             <td>-1</td>
	 *         </tr>
	 *         <tr>
	 *             <td>최소값 -> 0</td>
	 *             <td>0000</td>
	 *             <td>0</td>
	 *         </tr>
	 *         <tr>
	 *             <td>1</td>
	 *             <td>0001</td>
	 *             <td>1</td>
	 *         </tr>
	 *         <tr>
	 *             <td>2</td>
	 *             <td>0010</td>
	 *             <td>2</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 * 16비트로 표현할 수 있는 정수의 개수 : 2^16개(65536개)<br>
	 * short타입의 표현범위 : -2^16 ~ 2^15 -1 (-32768 ~ 32767)<br>
	 * char타입의 표현범위 : 0 ~ 2^16 -1 (0 ~ 65535)
	 */
	class Memo12 {

	}

	static class OverflowEx {

		public static void main(String[] args) {
			short sMin = -32768;
			short sMax = 32767;
			char cMin = 0;
			char cMax = 65535;

			System.out.println("sMin = " + sMin);
			System.out.println("sMin-1 = " + (short)(sMin - 1));
			System.out.println("sMax = " + sMax);
			System.out.println("sMax + 1 = " + (short)(sMax + 1));
			System.out.println("cMin = " + (int)cMin);
			System.out.println("cMin - 1 = " + (int)--cMin);
			System.out.println("cMax = " + (int)cMax);
			System.out.println("cMax + 1 = " + (int)++cMax);

		}

	}

	/**
	 * <h5>4.4 실수형 - float, double</h5><br>
	 * <h6>실수형의 범의와 정밀도</h6><br>
	 * 실수형은 실수를 저장하기 위한 타입으로 float와 double, 두 가지가 있다.
	 * <table border="1">
	 *     <thead>
	 *         <th>타입</th>
	 *         <th>저장 가능한 값의 범위(양수)</th>
	 *         <th>정밀도</th>
	 *         <th>크기</th>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>float</td>
	 *             <td>1.4 x 10<sup>-45</sup> ~ 3.4 x 10<sup>38</sup></td>
	 *             <td>7자리</td>
	 *             <td>32bit(4byte)</td>
	 *         </tr>
	 *         <tr>
	 *             <td>double</td>
	 *             <td>4.9 x 10<sup>-324</sup> ~ 1.8 x 10<sup>308</sup></td>
	 *             <td>15자리</td>
	 *             <td>64bit(8byte)</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 * float타입의 표현범위는 '-3.4x10<sup>38</sup> ~ 3.4x10<sup>38</sup>'이지만, '-1.4x10<sup>-45</sup> ~ 1.4x10<sup>-45</sup>'범위(0은 제외)의 값은 표현할 수 없다.<br>
	 * 실수형은 소수점도 표현해야 하므로 '얼머나 큰 값을 표현할 수 있는가'뿐만 아니라 '얼마나 0에 가깝게 표현할 수 있는가'도 중요하다.<br>
	 * 실수형에서도 변수의 값이 표현범위의 최대값을 벗어나면 '오버플로우'가 발생하는데, 정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 '무한대(infinity)'가 된다.<br>
	 * 정수형에는 없는 '언더플로우(underflow)'가 있는데, '언더플로우'는 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우를 말한다. 이 때 변수의 값은 0이된다.<br>
	 * int타입은 '부호와 값', 두 부분으로 이루어져있지만, float타입과 같은 실수형은 '부호(S), 지수(E), 가수(M)', 세 부분으로 이루어져 있다.<br>
	 * '2의 제곱을 곱한 형태(+-M x 2^E)'로 저장하기 때문에 이렇게 큰 범위의 값을 저장하는 것이 가능한 것이다.<br>
	 * 정수형과 달리 실수형은 오차가 발생할 수 있다는 단점이 있다. 그래서 실수형에는 표현할 수 있는 값의 범위뿐만 아니라 '정밀도(precision)'도 중요한 요소이다.<br>
	 * float타입은 정밀도가 7자리인데, 이것은 'a x 10^n'(1<=a<=10)의 형태로 표현된 '7자리의 10진수를 오차없이 저장할 수 있다'는 뜻으로 아래의 세값은 float타입의 변수에저장했을때 오차없이 저장할 수 있다.<br>
	 * 1234.567 = 1.234567 x 10^3<br>
	 * 0.00001234567 = 1.234567 x 10^-5<br>
	 * 1234567000 = 1.234567 x 10^9<br>
	 * 만일 7자리 이상의 정밀도가 필요하다면, 변수의 타입을 double로 해야 한다. double타입은 float타입보다 정밀도가 약 2배인, 10진수로 15자리의 정밀도를 가지므로 float타입보다 훨씬 더 정밀하게 값을 표현할 수 있다.<br>
	 * 실수형 값을 저장할 때, float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 저장하려는 '값의 범위'때문이 아니라 '보다 높은 정밀도'가 필요해서이다.<br>
	 * <small>double이라는 이름은 float보다 약 2배(double)의 정밀도를 갖는다는 의미에서 붙여진 것이다.</small><br>
	 * 연산속도의 향상이나 메모리릊 절약하려면 float를 선택하고, 더 큰 값의 범위라던가 더 높은 정밀도를 필요로 한다면 double을 선택해야 한다.<br>
	 */
	class Memo13 {

	}

	/**
	 * <h5>실수형의 저장형식</h5><br>
	 * 실수형은 정수형과 표현형식이 달라서, 실수형은 값을 부동소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 실수를 '&plusmn;M x 2^E'와 같은 형태로 표현하는 것을 말하며,<br>
	 * 부동소수점수는 부호(Sign), 지수(Exponent), 가수(Mantissa), 모두 세 부분으로 이루어져 있다.<br>
	 * float: 1 + 8 + 23 = 32 (4 byte)<br>
	 * S(1) E(8) M(23)<br>
	 * double: 1 + 11 + 52 = 64 (8 byte)<br>
	 * S(1) E(11) M(52)<br>
	 * 실수 표현형식의 구성요소<br>
	 * <table border="1">
	 *     <thead>
	 *         <tr>
	 *				<td>기호</td>
	 *         		<td>의미</td>
	 *         		<td>설명</td>
	 *         </tr>
	 *     </thead>
	 *     <tbody>
	 *         <tr>
	 *             <td>S</td>
	 *             <td>부호(Sign bit)</td>
	 *             <td>0이면 양수, 1이면 음수</td>
	 *         </tr>
	 *         <tr>
	 *             <td>E</td>
	 *             <td>지수(Exponent)</td>
	 *             <td>부호있는 정수, 지수의 범위는 -127 ~ 128(float), -1023 ~ 1024(double)</td>
	 *         </tr>
	 *         <tr>
	 *             <td>M</td>
	 *             <td>가수(Mantissa)</td>
	 *             <td>실제값을 저장하는 부분, 10진수로 7자리(float), 15자리(double)의 정밀도로 저장가능</td>
	 *         </tr>
	 *     </tbody>
	 * </table>
	 * <br>
	 */
	class Memo14 {

	}

	/**
	 * <h5>부호(Sign bit)</h5><br>
	 * 'S'는 부호비트(sign bit)를 의미하며 1 bit이다. 이 값이 0이면 양수를, 1이면 음수를 의미한다. 정수형과 달리 '2의 보수법'을 사용하지 않기 때문에 양의 실수를 음의 실수로 바꾸려면 그저 부호비트만 0에서 1로 변경하면 된다.<br>
	 * <h5>지수(Exponent)</h5><br>
	 * 'E'는 지수를 저장하는 부분으로 float의 경우, 8 bit의 저장공간을 갖는다. 지수는 '부호있는 정수'이고 8 bit로는 모두 2^8(=256)개의 값을 저장할 수 있다.<br>
	 * '-127 ~ 128'의 값이 저장된다. -127과 128은 '숫자 아님(NaN, Not a Number)'이나 '양의 무한대(POSITIVE_INFINITY)', '음의 무한대(NEGATIVE_INFINITY)'와 같이 특별한 값의 표현을 위해 예액되어 있으므로,<br>
	 * 실제로 사용가능한 지수의 범위는 '-126~127'이다.<br>
	 * <h5>가수(Mantissa)</h5><br>
	 * 'M'은 실제 값인 가수를 저장하는 부분으로 float의 경우, 2진수 23자리를 저장할 수 있다. 2진수 23자리로는 약 7자리의 10진수를 저장할 수 있는데 이것이 바로 float의 정밀도가 된다.<br>
	 * double은 가수를 저장할 수 있는 공간이 52자리로 float보다 약 2배이므로 double이 float보다 약 2배의 정밀도를 갖는 것이다.
	 */
	class Memo15 {

	}

}
