package chapter08;

/**
 * <h1>8. 예외처리 exception handling</h1>
 */
public class Chapter08 {

	/**
	 * <h1>1. 예외처리(exception handling)</h1><br>
	 * <h5>1.1 프로그램 오류</h5><br>
	 * 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. <br>
	 * 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다.<br>
	 * 이를 발생시점에 따라 '컴파일 에러(compile-time error)' 와 '런타임 에러(runtime error)'로 나눌 수 있는데,<br>
	 * 글자 그대로 '컴파일 에러'는 컴파일 할 때 발생하는 에러이고 프로그램의 실행도중에 발생하는 에러를 '런타임 에러'라고 한다.<br>
	 * 이 외에도 '논리적 에러(logical error)'가 있는데, 컴파일도 잘되고 실행도 잘되지만 의도한 것과 다르게 동작하는 것을 말한다.<br>
	 * <pre><code>
	 *     컴파일 에러 - 컴파일 시에 발생하는 에러
	 *     런타임 에러 - 실행 시에 발생하는 에러
	 *     논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것
	 * </code></pre>
	 * <br>
	 * 소스코드를 컴파일 하면 컴파일러가 소스코드(*.java)에 대해 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행하여 오류가 있는지를 알려 준다.<br>
	 * 컴파일러가 알려 준 에러들을 모두 수정해서 컴파일을 성공적으로 마치고 나면, 클래스 파일(*.class)이 생성되고, 생성된 클래스 파일을 실행할 수 있게 되는 것이다.<br>
	 * 컴파일을 에러없이 성공적으로 마쳤다고 해서 프로그램의 실행 시에도 에러가 발생하지 않는 것은 아니다.<br>
	 * 컴파일러가 소스코드의 기본적인 사항은 컴파일 시에 모두 걸러 줄 수는 있지만, 실행도중에 발생할 수 있는 잠재적인 오류까지 검사할 수 없기 떄문에 컴파일은 잘되었어도 실행 중에 에러에 의해서 잘못된 결과를 얻거나 프로그램이 비정상적으로 종료될 수 있다.<br>
	 * 런타임 에러를 방지하기 위해서는 프로그램의 실행도중 발생할 수 잇는 모든 경우의 수를 고려하여 이에 대한 대비를 하는 것이 필요하다.<br>
	 * 자바에서는 실행 시(runtime)발생할 수 있는 프로그램 오류를 '에러(error)'와 '예외(exception)', 두 가지로 구분하였다.<br>
	 * 에러는 메모리 부족(OutOfMemoryError)이나 스택오버플로우(StackOverflowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것이다.<br>
	 * <pre><code>
	 *     에러(error) - 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
	 *     예외(exception) - 프로그램 코드에 의해서 수습될 수 잇는 다소 미약한 오류
	 * </code></pre>
	 */
	class Memo1 {

	}

	/**
	 * <h5>1.2 예외 클래스의 계층구조</h5><br>
	 * 자바에서는 실행 시 발생할 수 있는 오류(Exception과 Error)를 클래스로 정의하였다.<br>
	 * 모든 클래스의 조상은 Object 클래스이므로 Exception과 Error 클래스 역시 Object 클래스의 자손들이다.<br>
	 * 모든 예외의 최고 조상은 Exception 클래스이다.<br>
	 * RuntimeException 클래스들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.<br>
	 * Exception 클래스들은 주로 외부의 영향으로 발생할 수 있는 것들로서, 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다.<br>
	 * <pre><code>
	 *     Exception 클래스들 - 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
	 *     RuntimeException 클래스들 - 프로그래머의 실수로 발생하는 예외
	 * </code></pre>
	 */
	class Memo2 {

	}

	/**
	 * <h5>1.3 예외처리하기 - try-catch문</h5><br>
	 * 프로그램의 실행도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다.<br>
	 * 예외처리(exception handling)란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다.<br>
	 * <pre><code>
	 *     예외처리(exception handling)의
	 *     		정의 - 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것
	 *     		목적 - 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것
	 * </code></pre>
	 * <br>
	 *<small>※ 에러와 예외는 모두 실행 시(runtime) 발생하는 오류이다.</small><br>
	 * 발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외(uncaught exception)는 JVM의 '예외처리기(UncaughtExceptionHandler)'가 받아서 예외의 원인을 화면에 출력한다.<br>
	 * <pre><code>
	 *     try {
	 *         // 예외가 발생할 가능성이 있는 문장들을 넣는다.
	 *     } catch(Exception1 e1) {
	 *         // Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
	 *     } catch(Exception2 e2) {
	 *         // Exception2가 발생햇을 경우, 이를 처리하기 위한 문장을 적는다.
	 *     } catch(ExceptionN eN) {
	 *         // ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
	 *     }
	 * </code></pre>
	 * <br>
	 * 하나의 try블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch블럭만 수행된다<br>
	 * 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않는다.<br>
	 * <small>※ if문과 달리, try블럭이나 catch블럭 내에 포함된 문장이 하나뿐이어도 괄호{}를 생략할 수 없다.</small><br>
	 * 하나의 메서드 내에 여러 개의 try-catch문이 사용될 수 있으며, try블럭 또는 catch블럭에 또 다른 try-catch문이 포함될 수 있다.<br>
	 * catch블럭 내의 코드에서도 예외가 발생할 수 있기 때문이다. catch블럭의 괄호 내에 선언된 변수는 catch블럭 내에서만 유효하기 때문이다.<br>
	 * ArithmeticException은 산술연산과정에서 오류가 있을 때 발생하는 예외이며, 정수는 0으로 나누는 것이 금지되어있기 때문에 발생한다. 실수를 0으로 나누는 것은 금지되어있지 않으며 예외가 발생하지 않는다.
	 */
	class Memo3 {

	}

	/**
	 * <h5>1.4 try-catch문에서의 흐름</h5><br>
	 * <pre><code>
	 *     ▶ try블럭 내에서 예외가 발생한 경우,
	 *     1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
	 *     2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.
	 *     ▶ try블럭 내에서 예외가 발생하지 않은 경우,
	 *     1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.
	 * </code></pre>
	 */
	class Memo4 {

	}

	/**
	 * <h5>1.5 예외의 발생과 catch블럭</h5><br>
	 * catch블럭은 괄호()와 블럭{} 두 부분으로 나눠져 있는데, 괄호()내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야한다.<br>
	 * 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다.<br>
	 * catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 instanceof연산자를 이용해서 검사하게 되는데, 검사결과가 true인 catch블럭을 만날 때까지 검사는 계속된다.<br>
	 * 검사결과가 true인 catch블럭을 찾게 되면 블럭에 있는 문장들을 모두 수행한 후에 try-catch문을 빠져나가고 에외는 처리되지만, 검사결과가 true인 catch블럭이 하나도 없으면 예외는 처리되지 않는다.<br>
	 * 모든 예외 클래스는 Exception클래스의 자손이므로, catch블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해서 처리된다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>printStackTrace()와 getMessage()</h5><br>
	 * 예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, getMessage()와 printStackTrace()를 통해서 이 정보들을 얻을 수 있다.<br>
	 * catch블럭의 괄호()에 선언된 참조변수를 통해 이 인스턴스에 접근할 수 있다.<br>
	 * <pre><code>
	 *     printStaceTrace() - 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메세지를 화면에 출력한다.
	 *     getMessage() - 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있다.
	 * </code></pre>
	 * <br>
	 * <small>※printStackTrace(PrintStream s) 또는 printStackTrace(PrintWriter s)를 사용하면 발생한 예외에 대한 정보를 파일에 저장할 수도 있다.</small>
	 */
	class Memo6 {

	}

	/**
	 * <h5>멀티 catch블럭</h5><br>
	 * JDK1.7부터 여러 catch블럭을 '|'기호를 이용해서, 하나의 catch블럭으로 합칠 수 있게 되었으며, 이를 '멀티 catch블럭'이라고 한다.<br>
	 * '|' 기호로 연결할 수 있는 예외 클래스의 개수에는 제한이 없다.<br>
	 * <small>※ 멀티 catch블럭에 사용되는 '|'는 논리 연산자가 아니라 기호이다.</small>
	 * <pre><code>
	 *     try {
	 *         ...
	 *     } catch(ExceptionA e) {
	 *         e.printStackTrace();
	 *     } catch(ExceptionB e2) {
	 *         e2.printStackTrace();
	 *     }
	 *     ↓
	 *     try {
	 *         ...
	 *     } catch(ExceptionA | ExceptionB e) {
	 *         e.printStackTrace();
	 *     }
	 * </code></pre>
	 * <br>
	 * 만일 멀티 catch블럭의 '|'기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일 에러가 발생한다.<br>
	 * 왜냐하면, 두 예외 클래스가 조상과 자손의 관계에 있다면, 그냥 조상 클래스만 써주는 것과 똑같기 때문이다. 불필요한 코드는 제거하라는 의미에서 에러가 발생하는 것이다.<br>
	 * 멀티 catch는 하나의 catch블럭으로 여러 예외를 처리하는 것이기 때문에, 발생한 예외를 멀티 catch블럭으로 처리하게 되었을 때, 멀티 catch블럭 내에서는 실제로 어떤 예외가 발생한 것인지 알 수 없다.<br>
	 * 그래서 참조변수 e로 멀티 catch블럭에 '|'기호로 연결된 예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만 사용할 수 있다.
	 */
	class Memo7 {

	}

	/**
	 * <h5>1.6 예외 발생시키기</h5><br>
	 * 키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있다.<br>
	 * <pre><code>
	 *     1. 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스들의 객체를 만든 다음
	 *     Exception e = new Exception("고의로 발생시켰음");
	 *     2. 키워드 throw를 이용해서 예외를 발생시킨다.
	 *     throw e;
	 * </code></pre>
	 * <br>
	 * 컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들은 'unchecked예외'라고 부르며, 예외처리를 확인하는 Exception클래스들은 'checked예외'라고 부른다.
	 */
	class Memo8 {

	}

	/**
	 * <h5>1.7 메서드에 예외 선언하기</h5><br>
	 * 예외를 처리하는 방법에는 지금까지 배워 온 try-catch문을 사용하는 것 외에, 예외를 메서드에 선언하는 방법이 있다.<br>
	 * 메서드에 예외를 선언하려면, 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다.<br>
	 * 예외가 여러 개일 경우에는 쉼표(,)로 구분한다.<br>
	 * <pre><code>
	 *     void method() throws Exception1, Exception2 ... ExceptionN {
	 *         // 메서드의 내용
	 *     }
	 * </code></pre>
	 * <br>
	 * 자바에서는 메서드를 작성할 때 메서드 내에서 발생할 가능성이 있는 예외를 메서드의 선언부에 명시하여 이 메서드를 사용하는 쪽에서는 이에 대한 처리를 하도록 강요하기 때문에,<br>
	 * 프로그래머들의 짐을 덜어 주는 것은 물론이고 보다 견고한 프로그램 코드를 작성할 수 있도록 도와준다.<br>
	 * 메서드에 예외를 선언할 때 일반적으로 RuntimeException클래스들은 적지 않는다. 이 들을 메서드 선언부의 throws에 선언한다고 해서 문제가 되지는 않지만, 보통 반드시 처리해주어야 하는 예외들만 선언한다.<br>
	 * 사실 예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것이다.<br>
	 * 예외를 전달받은 메서드가 또다시 자신을 호출한 메서드에게 전달할 수 있으며, 이런 식으로 계속 호출스택에 있는 메서드들을 따라 전달되다가 제일 마지막에 있는 main메서드에서도 예외가 처리되지 않으면, main메서드마저 종료되어 프로그램이 전체가 종료된다.
	 */
	class Memo9 {

	}

	/**
	 * <h5>1.8 finally블럭</h5><br>
	 * finally블럭은 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다.<br>
	 * try-catch문의 끝에 선택적으로 덧붙여 사용할 수 있으며, try-catch-finally의 순서로 구성된다.<br>
	 * <pre><code>
	 *     try {
	 *         // 예외가 발생할 가능성이 있는 문장들을 넣는다.
	 *     } catch(Exception e1) {
	 *         // 예외처리를 위한 문장을 적는다.
	 *     } finally {
	 *     	   // 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣는다.
	 *     	   // finally블럭은 try-catch문의 맨 마지막에 위치해야한다.
	 *     }
	 * </code></pre>
	 * <br>
	 * 예외가 발생한 경우에는 'try -> catch -> finally'의 순으로 실행되고, 예외가 발생하지 않은 경우에는 'try -> finally'의 순으로 실행된다.<br>
	 * try블럭에서 return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메서드를 종료한다.<br>
	 * catch블럭의 문장 수행 중에 return문을 만나도 finally블럭의 문장들은 수행된다.
	 */
	class Memo10 {

	}

	/**
	 * <h5>1.9 자동 자원 반환 - try - with - resources문</h5><br>
	 * JDK1.7부터 try - with - resources문이라는 try - catch 문의 변형이 새로 추가되었다.<br>
	 * 주로 입출력에 사용되는 클래스 중에서는 사용한 후에 꼭 닫아 줘야 하는 것들이 있다. 그래야 사용했던 자원(resources)이 반환되기 때문이다.<br>
	 * try - with - resources문의 괄호()안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동적으로 close()가 호출된다.<br>
	 * 그 다음에 catch블럭 또는 finally블럭이 수행된다.<br>
	 * <small>※ try블럭의 괄호()안에 변수를 선언하는 것도 가능하며, 선언된 변수는 try블럭 내에서만 사용할 수 있다.</small><br>
	 * 이처럼 try - with - resources문에 의해 자동으로 객체의 close()가 호출될 수 있으려면, 클래스가 AutoCloseable이라는 인터페이스를 구현한 것이어야만 한다.<br>
	 * Throwable에는 억제된 예외와 관련된 다음과 같은 메서드가 정의되어 있다.<br>
	 * <pre><code>
	 *     void addSuppressed(Throwable exception) - 억제된 예외를 추가
	 *     Throwable[] getSuppressed() - 억제된 예외(배열)를 반환
	 * </code></pre>
	 */
	class Memo11 {

	}

	/**
	 * <h5>1.10 사용자정의 예외 만들기</h5><br>
	 * 기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있다.<br>
	 * 보통 Exception클래스 또는 RuntimeException클래스로부터 상속받아 클래스를 만들지만, 필요에 따라서 알맞은 예외 클래스를 선택할 수 있다.<br>
	 * <pre><code>
	 *     class MyException extends Exception {
	 *         MyException(String msg) {
	 *             super(msg); // 조상인 Exception클래스의 생성자를 호출한다.
	 *         }
	 *     }
	 * </code></pre><br>
	 * 기존의 예외 클래스는 주로 Exception을 상속받아서 'checked예외'로 작성하는 경우가 많았지만, 요즘은 예외처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아서 작성하는 쪽으로 바뀌어가고 있다.<br>
	 * 'checked예외'는 반드시 예외처리를 해주어야 하기 때문에 예외처리가 불필요한 경우에도 try - catch 문을 넣어서 코드가 복잡해지기 때문이다.
	 */
	class Memo12 {

	}

	/**
	 * <h5>1.11 예외 되던지기(exception re-throwing)</h5><br>
	 * 한 메서드에서 발생할 수 있는 예외가 여럿인 경우, 몇 개는 try-catch문을 통해서 메서드 내에서 자체적으로 처리하고,<br>
	 * 그 나머지는 선언부에 지정하여 호출한 메서드에서 처리하도록 함으로써, 양쪽에서 나눠서 처리되도록 할 수 있다.<br>
	 * 단 하나의 예외에 대해서도 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하도록 할 수 있다.<br>
	 * 예외를 처리한 후에 인위적으로 다시 발생시키는 방법을 통해서 가능한데, 이것을 '예외 되던지기(exception re-throwing)'라고 한다.<br>
	 * 먼저 예외가 발생할 가능성이 있는 메서드에서 try-catch문을 사용해서 예외를 처리해주고 catch문에서 필요한 작업을 행한 후에 throw문을 사용해서 예외를 다시 발생시킨다.<br>
	 * 주의할 점은 예외가 발생할 메서드에서는 try-catch문을 사용해서 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다는 것이다.<br>
	 * 반환값이 있는 return문의 경우, catch블럭에도 return문이 있어야 한다. 예외가 발생했을 경우에도 값을 반환해야하기 때문이다.<br>
	 * catch블럭에서 예외 되던지기를 해서 호출한 메서드로 예외를 전달하면, return문이 없어도 된다.<br>
	 * <small>※ finally블럭 내에도 return문을 사용할 수 있으며, try블럭이나 catch블럭의 return문 다음에 수행된다. 최종적으로 finally블럭 내의 return문의 값이 반환된다.</small>
	 */
	class Memo13 {

	}

	/**
	 * <h5>1.12 연결된 예외(chained exception)</h5><br>
	 * 한 예외가 다른 예외를 발생시킬 수도 있다. 예를 들어 예외 A가 예외 B를 발생시켰다면, A를 B의 '원인 예외(cause exception)'라고 한다.<br>
	 * <pre><code>
	 *     Throwable initCause(Throwable cause) - 지정한 예외를 원인 예외로 등록
	 *     Throwable getCause() - 원인 예외를 반환
	 * </code></pre>
	 * <br>
	 * checked예외를 unchecked예외로 바꿀 수 있또록 하기 위해서이다.<br>
	 * checked예외로 예외처리를 강제한 이유는 프로그래밍 경험이 적은 사람도 보다 견고한 프로그램을 작성할 수 있도록 유도하기 위한 것이었다.<br>
	 * checked예외가 발생해도 예외를 처리할 수 없는 상황이 하나둘 발생하기 시작했다.<br>
	 * 이럴 때 할 수 있는 일이라곤 그저 의미없는 try-catch문을 추가하는 것뿐인데, checked예외를 unchecked예외로 바꾸면 예외처리가 선택적이 되므로 억지로 예외처리를 하지 않아도 된다.
	 */
	class Memo14 {

	}

}
