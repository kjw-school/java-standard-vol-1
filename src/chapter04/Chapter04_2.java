package chapter04;

/**
 * <h1>2. 반복문 - for, while, do-while</h1><br>
 * 반복문은 어떤 작업이 반복적으로 수행되도록 할 때 사용되며, 반복문의 종류로는 for문과 while문, 그리고 while문의 변형인 do-while문이 있다.<br>
 * for문이나 while문에 속한 문장은 조건에 따라 한 번도 수행되지 않을 수 있지만 do-while문에 속한 문장은 무조건 최소한 한 번은 수행될 것이 보장된다.<br>
 * if문과 마찬가지로 조건식의 결과가 true이면 참이고, false이면 거짓으로 간주된다.
 */
public class Chapter04_2 {

	/**
	 * <h5>2.1 for문</h5><br>
	 * for문은 반복 횟수를 알고 있을 때 적합하다.<br>
	 * <pre><code>
	 *     for(int i=1; i<=5; i++) {
	 *     		System.out.println("I can do it.");
	 *     }
	 * int i=1;(1부터), i<=5;(5까지), i++(1씩 증가)
	 * </code></pre>
	 */
	class Memo1 {

	}

	/**
	 * <h5>for문의 구조와 수행순서</h5><br>
	 * for문은 아래와 같이 '초기화', '조건식', '증감식', '블럭{}', 모두 4부분으로 이루어져 있으며, 조건식이 참인 동안 블럭{} 내의 문장들을 반복하다 거짓이 되면 반복문을 벗어난다.<br>
	 * <pre><code>
	 *     for(초기화; 조건식; 증감식) {
	 *         // 조건식이 참일 때 수행될 문장들을 적는다.
	 *     }
	 * </code></pre>
	 * <br>
	 * 제일 먼저'1. 초기화'가 수행되고, 그 이후부터는 조건식이 참인 동안 '2. 조건식 -> 3'수행될 문장 -> '4. 증감식'의 순서로 계속 반복된다.<br>
	 * 그러다가 조건식이 거짓이 되면, for문 전체를 빠져나가게 된다.
	 * <pre><code>
	 *     for(1. 초기화; 2. 조건식; 4. 증감식) {
	 *         3. 수행될 문장
	 *     }
	 *     1 -> 2 -> 3 -> 4
	 * </code></pre>
	 */
	class Memo2 {

	}

	/**
	 * <h5>초기화</h5><br>
	 * 반복문에 사용될 변수를 초기화하는 부분이며 처음에 한번만 수행된다.<br>
	 * 보통 변수 하나로 for문을 제어하지만, 둘 이상의 변수가 필요할 때는 아래와 같이 콤마','를 구분자로 변수를 초기화하면 된다.<br>
	 * 두 변수의 타입은 같아야 한다.
	 */
	class Memo3 {

	}

	/**
	 * <h5>조건식</h5><br>
	 * 조건식의 값이 참(true)이면 반복을 계속하고, 거짓(false)이면 반복을 중단하고 for문을 벗어난다. for의 뜻이 '~하는 동안'이므로 조건식이 '참인 동안'반복을 계속한다고 생각하면 쉽다.<br>
	 * <pre><code>
	 *     for(int i=1; i<=10; i++) { ... } // 'i<=10' 가 참인 동안 블럭{}안의 문장들을 반복
	 * </code></pre>
	 */
	class Memo4 {

	}

	/**
	 * <h5>증감식</h5><br>
	 * 반복문을 제어하는 변수의 값을 증가 또는 감소시키는 식이다.<br>
	 * 매 반복마다 변수의 값이 증감식에 의해서 점진적으로 변하다가 결국 조건식이 거짓이 되어 for문을 벗어나게 된다.<br>
	 * 변수의 값을 1씩 증가시키는 연산자 '++'이 증감식에 주로 사용되지만, 다음과 같이 다양한 연산자들로 증감식을 작성할 수도 있다.<br>
	 * <pre><code>
	 *     for(;;) { ... } // 초기화, 조건식, 증감식 모두 생략. 조건식은 참이 된다.
	 * </code></pre>
	 * <br>
	 * 조건식이 생략된 경우, 참(true)으로 간주되어 무한 반복문이 된다.
	 */
	class Memo5 {

	}

	/**
	 * <h5>향상된 for문(enhanced for statement)</h5><br>
	 * <pre><code>
	 *     for(타입 변수명 : 배열 또는 컬렉션) {
	 *         // 반복할 문장
	 *     }
	 * </code></pre>
	 * <br>
	 * 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.<br>
	 * 반복문의 괄호{}내에서는 이 변수를 사용해서 코드를 작성한다.<br>
	 * 향상된 for문은 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
	 */
	class Memo6 {

	}

	/**
	 * <h5>2.2 while문</h5><br>
	 * if문처럼 조건식과 블럭{}만으로 이루어져 있다, 다만 if문과 달리 while문은 조건식이 '참(true)인 동안', 즉 조건식이 거짓이 될 때까지 블럭{} 내의 문장을 반복한다.<br>
	 * <pre><code>
	 *     while(조건식) {
	 *         // 조건식의 연산결과가 참(true)인 동안, 반복될 문장들을 적는다.
	 *     }
	 * </code></pre>
	 * <br>
	 * <pre><code>
	 *     while(1. 조건식) {
	 *         2. 수행될 문장
	 *     }
	 *     1. 조건식이 참(true)이면 블럭{}안으로 들어가고, 거짓(false)이면 while문을 벗어난다.
	 *     2. 블럭{}의 문장을 수행하고 다시 조건식으로 돌아간다.
	 * </code></pre>
	 */
	class Memo7 {

	}

	/**
	 * <h5>for문과 while문의 비교</h5><br>
	 * 만일 초기화나 증감식이 필요하지 않은 경우라면, while문이 더 적합할 것이다.
	 */
	class Memo8 {

	}

	/**
	 * <h5>while문의 조건식은 생략불가</h5><br>
	 * 한 가지 주의할 점은 for문과 달리 while문의 조건식의 생략할 수 없다는 것이다.<br>
	 * <pre><code>
	 *     while() { // 에러. 조건식이 없음.
	 *         ...
	 *     }
	 * </code></pre>
	 */
	class Memo9 {

	}

	/**
	 * <h5>2.3 do-while문</h5><br>
	 * while문과 반대로 블럭{}을 먼저 수행한 후에 조건식을 평가한다.<br>
	 * while문은 조건식의 결과에 따라 블럭{}이 한 번도 수행되지 않을 수 있지만, do-while문은 최소한 한번은 수행될 것을 보장한다.<br>
	 * <pre><code>
	 *     do {
	 *         // 조건식의 연산결과가 참일 때 수행될 문장들을 적는다.
	 *     } while(조건식); <- 끝에 ';'을 잊지 않도록 주의
	 * </code></pre>
	 */
	class Memo10 {

	}

	/**
	 * <h5>2.4 break문</h5><br>
	 * break문은 자신이 포함된 가장 가까운 반복문을 벗어난다.
	 */
	class Memo11 {

	}

	/**
	 * <h5>2.5 continue문</h5><br>
	 * continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.<br>
	 * for문의 경우 증감식으로 이동하며, while문과 do-while문의 경우 조건식으로 이동한다.<br>
	 * continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다르다. 주로 if문과 함께 사용되어 특정 조건을 만족하는 경우에 continue문 이후의 문장들을 수행하지 않고 다음 반복으로 넘어가서 계속 진행하도록 한다.
	 */
	class Memo12 {

	}

	/**
	 * <h5>2.6 이름 붙은 반복문</h5><br>
	 * break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없다.<br>
	 * 이때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.<br>
	 * <pre><code>
	 *     outer:
	 *     while(true) {
	 *         ...
	 *         for(;;) {
	 *             ...
	 *             if(num == 0) // 계산 종료. for문을 벗아난다.
	 *             		break;
	 *             if(num == 99) // 전체 종료. for문과 while문 모두 벗어난다.
	 *                  break outer;
	 *             ...
	 *         } // for(;;)
	 *     } // while(true)
	 * </code></pre>
	 */
	class Memo13 {

	}

}
